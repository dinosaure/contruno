# Contruno, a TLS termination proxy as a MirageOS

<p align="center">
  <img src="https://github.com/dinosaure/contruno/blob/main/img/uno.jpg?raw=true">
</p>

`contruno` is a TLS termination proxy is a proxy server that acts as an
intermediary point between client and server applications, and is used to
establish TLS tunnels with let's encrypt certificates.

From a Git repository which contains TLS certificates and private keys
delivered by let's encrypt, the user is able launch into its private network a
simple HTTP server. `contruno` does the bridge between the client which
initiates a TLS tunnel with a specific certificate from the Git repository and
its HTTP server.

`contruno` handles expiration of certificates and do the let's encrypt
challenge (the HTTP challenge) when one of is expired. Then, it renegociates
current connections with the new certificate and save it (with its private key)
into the Git repository.

If `contruno` shutdowns, you can restart it and, from the same Git repository,
it will restart the TLS termination proxy with all current certificates.

## How to use it?

**status**: experimental

`contruno` wants few informations:
- The Git repository
- The SSH seed to generate (via _fortuna_) the private SSH key
- A password
- If you want to use production ready certificates or not
- Email, certificate seed and account seed (optional)

The Git repository should be well formed. A tool exists, `contruno.add` to put
a new certificate (with its private key) into the Git repository and signals
the unikernel (via the password) to reload certificates.

### How to compile the project?

As any MirageOS projects, you have the `unikernel.ml` which is the application
and the `config.ml` which is the manifest to compile/craft the unikernel. This
is the process to compile a full Operating System which can be virtualized
_via_ `kvm` (we require `opam`):
```sh
$ git clone https://github.com/dinosaure/contruno
$ cd contruno/mirage
% opam install mirage
$ mirage configure -t hvt
$ make depends
$ mirage build
```

And you have an image `contruno.hvt` which can be deployed.

### How to deploy the _unikernel_?

Let's start with a simple network topology with a private network 10.0.0.0 on a
bridge `br1` and your interface (connected to internet) `eth0`.

At the beginning, you need a virtual interface TAP:
```sh
# ip tuntap add mode tap tap100
# ip link set dev tap100 up
# brctl addif br1 tap100
```

In such layout, you need to "redirect" TCP/IP packets from eht0:443 to your
private IP address 10.0.0.2 (your unikernel). It's possible to do that via
`iptables`:
```sh
# sysctl -w net.ipv4.ip_forward=1
# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
# iptables -t nat -A FORWARD -i tap100 -o br1 -j ACCEPT
# iptables -t nat -A FORWARD -i br1 -o tap100 -j ACCEPT
# iptables -t nat -A POSTROUTING -o br1 -j MASQUEREADE
# iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT \
#   --to-destination 10.0.0.2:443
```

#### How to make a simple Git repository?

`contruno` needs a Git repository to store certificates for each domains. It's
easy to create a private Git repository and, in our context, it's perfect.
Indeed, the Git repository will contains private keys, so it should only be
accessible on your private network.

We will create our own Git repository with a specific SSH public key generated
by `awa_gen_key`:
```sh
$ awa_gen_key > awa.gen.key
$ cat awa.gen.key | head -n1
seed is U01hpCOJ/MHLri7YBi7NBXqZ8TXDkVyXSb7CdGQr
# adduser git
# su git
$ cd
$ mkdir .ssh && chmod 700 .ssh
$ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys
$ cat awa.gen.key | tail -n1 >> .ssh/authorized_keys
$ mkdir certificates.git
$ cd certificates.git
$ git init --bare
$ FIRST_COMMIT=`git commit-tree $(git write-tree) -m .`
$ git update-ref "refs/heads/master" $FIRST_COMMIT
```

So we just make a Git repository with one commit. Into the
`.ssh/authorized_keys`, you should put your SSH public key to be able to pull
and push on this local repository. The seed generated by `awa_gen_key` is
important. We will pass it to the unikernel to be able to reconstruct the SSH
private key then (and let the unikernel to `pull`/`push`).

Now, we are almost ready to deploy our unikernel. The last step is to add
a certificate. In this example, we will do the challenge via _certbot_ to show
how to add a new domain name/certificate into the store - but keep in your mind
that when the certificate expires, `contruno` is able to redo the challenge and
get a new certificate.

**NOTE**: in this example, we get a non-productive certificate
(see `--server`).

```sh
$ sudo certbot certonly --standalone \
  --server https://acme-staging-v02.api.letsencrypt.org/directory \
  --register-unsafely-without-email \
  -d foo.bar
$ sudo cp /etc/letsencrypt/live/foo.bar/* .
$ contruno.add --cert cert.pem -h foo.bar -i 10.0.0.2 \
  -p privkey.pem --pass foo \
  -r git@localhost:certificates.git -t 10.0.0.3
```

`10.0.0.3` is where you have our HTTP (without TLS) website. Then, the tool
will push (_via_ SSH - so you need to add your public key into your
`/home/git/.ssh/authorized_keys`) the new certificate to deserve
`https://foo.bar`.

Currently, the tool fails at the end because we did not yet launched our
unikernel and it tries to signal it that the Git repository was changed.

Finally, we can deploy our unikernel!

### How to deploy?

At this stage, we need to keep our unikernel alive. The usual way to do that is
to use `screen` (or to _daemonize_ the process). By this way, the unikernel
still continue to run even if we are disconnected. Then, we need to have an
access to `kvm`, so the current user needs to be a part of the `kvm` group.
Finally, we will use `solo5-hvt` has our tender to launch our unikernel:
```sh
$ usermod -aG kvm $USER
$ screen
$ solo5-hvt --net:service=tap100 contruno.hvt -- \
  --ipv4=10.0.0.2/24 \
  --ipv4-gateway=10.0.0.1 \
  --remote git@10.0.0.1:certificates.git \
  --pass foo \
  --production false \
  --ssh-ssh U01hpCOJ/MHLri7YBi7NBXqZ8TXDkVyXSb7CdGQr \
```

And, voil√†!
